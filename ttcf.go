package ttcf

import (
	"time"
	"github.com/rivo/tview"
	"github.com/gdamore/tcell/v2"
)

type Entry struct {
	Head,
	Body 	string
	Time  time.Time
	ID		uint64	/* Generated by client, ideally unique but that's their problem */
}

type Config struct {
	BodyMax,
	HeadMax,
	InputMax,
	CollectionMax int
	Title,
	Prompt,
	TimeFormat,
	Placeholder string
	InputCalls func(string) bool /* On input submission, function (of the client) called */
}

type Chat struct {
	Config Config
	Collection []Entry
}

var (
	log			[]Entry
	lastID	uint64
	flex		 *tview.Flex
	input		*tview.InputField
	app			*tview.Application
	bar,
	box			*tview.TextView
	Fakechat *Chat
)

func Init(c Config) (err error, chat Chat) {
	initUI(c)
	return nil, Chat{c, log}
}

func initUI(c Config) {
	app = tview.NewApplication().
		SetBeforeDrawFunc(func(s tcell.Screen) bool {
			s.Clear()
			return false
		})

	box = tview.NewTextView().
		SetDynamicColors(true).
		SetScrollable(true).
		SetChangedFunc(func() {
			box.ScrollToEnd()
			go app.Draw()
		}).SetTextColor(0)

	input = tview.NewInputField().
		SetFieldTextColor(0).
		SetPlaceholderTextColor(7).
		SetFieldBackgroundColor(0).
		SetLabel("[-:-:d]" + c.Prompt).
		SetLabelColor(0).
		SetPlaceholder(c.Placeholder).
		SetFieldWidth(int(c.InputMax))

	bar = tview.NewTextView().
		SetTextAlign(tview.AlignCenter).
		SetDynamicColors(true).
		SetText(c.Title).
		SetChangedFunc(func() {
			box.ScrollToEnd()
			go app.Draw()
		}).SetTextColor(0)

	box.SetBackgroundColor(0)
	bar.SetBackgroundColor(0)

	flex = tview.NewFlex().
		SetDirection(tview.FlexRow).
		AddItem(bar, 2, 0, false).
		AddItem(box, 0, 3, false)

	input.SetDoneFunc(func(key tcell.Key) {
		if c.InputCalls(input.GetText()) == true {
			input.SetText("")
		}
	})

	go app.SetRoot(flex, true).SetFocus(input).EnableMouse(false).Run()

}

func (c *Chat) PushEntry(e Entry) error {
	c.Collection = append(c.Collection, e)

	if len(c.Collection) > c.Config.CollectionMax {
		c.Collection = c.Collection[1:] /* Keep collection within bounds */
	}

	drawCollection(c.Collection)
	return nil
}

func print(s string) {
	if !(len(s) < 0) {
		box.SetText(box.GetText(false) + s)
	}
}

func drawCollection(collection []Entry) {
	s := ""
	for _, c := range collection {
		s += c.Head + ":" + c.Time.Format(time.RFC3339) +"\n" + c.Body +"\n"
		s += "\n"
	}

	print(s)
}
